Programming Computable Functions (PCF) is a programming language that is based on the Simply Typed $\lambda$ Calculus, with the addition of a "fix" operator, that allows us to write recursive functions using fixpoint recursion.

\section{Definition of PCF}

\subsection{Types}
There are some versions of PCF in different papers and books (such as \citep{Plotkin77}, \citep{Gunter92}) where some use Booleans and Natural Numbers for the base types. Here we just use Natural numbers, where $0$ represents false and any non zero number represents true. We define our types using the following grammar:\\

\[A ::= \nat \ | A \to B\] 

\subsection{Expressions}

The allowable expressions include variables (represented by $x$), a constant $z$ representing the number $0$, and a successor function $s(e)$, which takes any expression as input and returns its successor. 

$\case$ takes an expression $e$, which we assume is a numerical value. If $e$ is zero, we return an expression $e_0$, otherwise we have the successor of some value $x$ and we return the expression $e_S$.

Then we have function application, in which a function $e$ is applied to an expression $e'$, and $\lambda$-abstraction, which denotes a function $e$ that takes an input $x$ of type $A$.

Our last expression is the fixpoint expression, which takes a value $x$ as input to a larger function $e$.

The grammar for expressions is:

\[e ::=  \ x \ | \ z \ | \ s(e) \  |  \ \case \ (e, z \mapsto e_0 , s(x) \mapsto e_S) \ |\ e \ e' \  | \lambda x:A.e \ | \ \fix \ x:A . \ e\]

\section{Type System for PCF}
$\Gamma$ is an example of a typing context, which is a function that maps variables to their types. For example, if we have an expression $x : A$ in the context, then $\Gamma(x) = A$. We write $\Gamma \vdash e : A$ for the context associated with an expression $e$ of type $A$.

Therefore we need a typing rule for each expression in PCF, which if satisfied means that we are allowed to write that expression. The typing rules are given as inference rules, where our assumptions are above the line and the conclusion underneath:

$$
\inferrule [variables]{ \Gamma(x) = A }
 {\Gamma \vdash x : A}
\hspace{1cm}
\inferrule [zero]{ \ }
 {\Gamma \vdash z : \nat}
\hspace{1cm}
\inferrule [succ]{ \Gamma \vdash e : Nat }
 {\Gamma \vdash s(e) : \nat}
$$

For \emph{variables}, if $x$ is in the domain of $\Gamma$, then we can conclude that we have a variable of that type.

$z$ is a constant, so it needs no assumptions.

For \emph{successor}, we must have an expression $e$ of type $\nat$ that we can apply the successor function to. We then know we have $s(e)$ of type $\nat$.

$$
\inferrule [case]{\Gamma \vdash e : \nat \\  \Gamma \vdash e_0 : A \\  \Gamma , x:\nat\vdash e_S : A}
  {\Gamma \vdash \ \case \ (e, z \mapsto e_0 , s(x) \mapsto e_S) \  : A}  
$$

For $\case$, we must have an expression $e$ of type $\nat$ to evaluate. Then we must have some other expressions $e_0$ and $e_S$ to return, which can be of any type, as long as they are the same type. As the condition of $e_S$ contains a specific $x$ value, we must also know that this is well typed. Therefore we add $x : \nat$ to the context of $e_S$.

$$
\inferrule [application]{\Gamma \vdash e : A \to B \\  \Gamma \vdash e' : A}
  {\Gamma \vdash e \ e' : B}
  \hspace{1cm}
\inferrule [abstraction] {\Gamma , x : A \vdash  e : B}
  {\Gamma \vdash \lambda x : A. e : A \to B}  
$$

For application, $e$ must have a function type and $e'$ must have the same type as the domain of $e$. Then we can apply $e$ to $e'$ to get the expression $e \ e'$ of the type of the codomain of $e$.

For $\lambda$ abstraction, we need an expression $e$ of some type $B$ and we must know that the parameter $x$ is in the context of this expression, to be able to use it in the $\lambda$ abstraction. Then in the conclusion, as $x$ is now bound to the expression, we remove it from the context of $B$.

$$
\inferrule [fix]{\Gamma, x : A \vdash e : A }
  {\Gamma \vdash \  \fix \ x:A . \ e : A}
$$

The fixpoint case is exactly the same as $\lambda$ abstraction, where the $x$ is bound to the fixpoint expression.

\vspace{0.5cm}

For any well typed PCF expression, we can obtain a derivation tree, where the root is the whole expression and the branches go up until we end up with the variables and constants of the expression at the leaves.

We also note that given a typing context $\Gamma$, an expression $e$ and a type $A$ such that we have the typing judgement $\Gamma \vdash e : A$, there is only one possible derivation of this judgement.

\chapter{Operational Semantics of PCF}\label{ch4}
Now we have defined the syntax and typing rules of PCF, we can use this to define its operational semantics.

We use the \textbf{Call By Name} evaluation strategy, which means that function arguments are placed into the body of the function and evaluated within the entire function's evaluation, instead of before.

The semantics we define are \textbf{small step} semantics, which means that in $e \mapsto e'$, the transition relation $\mapsto$ must take an expression $e$ to another expression $e'$ in only one step.

The first rules we have are \textbf{congruence rules}, which use the assumption $e \mapsto e'$ to replace $e$ with $e'$ in the whole expression. We can define these rules for any PCF expression that has an expression as a parameter, so this will be function application, successor and case:

$$
\inferrule { e_0 \mapsto e_0'} {e_0 \ e_1 \mapsto e_0' \ e_1}
\hspace{1cm}
\inferrule { e \mapsto e'} {s(e) \mapsto s(e')}
$$

$$
\inferrule { e \mapsto e'} {\case \ (e, z \to e_0 , s(x) \to e_S) \mapsto \case \ (e', z \to e_0 , s(x) \to e_S)}
$$

(Note that we could have given the typing contexts before each expression in the evaluation rules, but as they do not change, we can omit them. The same is also true for the rest of the rules we define below.) 

Then we define rules on individual expressions. Note that the case rule above was only defined on expressions that reduce. The one defined below is only defined for \textbf{values}, which are expressions that have no applicable evaluation rule (including zero, successors of values, and lambda abstractions). This ensures that there is only one possible rule to apply to any expression.



$$
\inferrule{ \ }
 {(\lambda x: A .\ e) \ e' \mapsto [e'/x]e}
$$

The above rule states that given a function application, where the function is defined by a $\lambda$-abstracttion, we substitute $e'$ for $x$ in the expression $e$. This means that we replace every occurrence of $x$ in $e$ with the expression $e'$.

$$
\inferrule{ \ }
{\case \ (z, z \to e_0 , s(x) \to e_S) \mapsto e_0}
$$
$$
\inferrule{ \ }
{\case \ (s(v), z \to e_0 , s(x) \to e_S) \mapsto [v/x]e_S}
$$

The above rules give the evaluation of case, when we have a value as the condition expression. The first rule states that if $e = z$, then our result will be $e_0$. If $e = s(v)$, our result is $e_S$ , but we must also substitute $v$ for $x$ in $e_S$ (as $e_S$ is defined for a bound variable $x$, which we now know is equal to $v$).

$$
\inferrule{ \ }
{\fix \ x:A. e \mapsto [\fix \ x:A. e/x]e}
$$

The above rule states that we replace the bound variable $x$ in the expression $e$ with the entire fixpoint expression. This replaces a parameter in $e$, which should be the recursive call, with the contents of the function, so that we can evaluate it all again. Then when we get to that point in the new evaluation, we will replace $x$ with the whole expression. We can keep doing this infinitely, and keep expanding the evaluation in the following way:

\[ \fix \ x:A. e \mapsto [\fix \ x:A. e/x]e \mapsto 
[[\fix \ x:A. e/x]e/x]e
\mapsto
[[[\fix \ x:A. e/x]e/x]e/x]e \dots \]

We give an example of a function that uses the fixpoint operator in the following section.

\section{Example of a program in PCF}

\input{progREPORT.tex}

\chapter{Type Safety}\label{safe}
Type Safety is an important property of a programming language, as it proves that well typed programs do not go wrong. It is usually expressed as a property of the operational semantics, which we have defined in the previous chapter (see Chapter \ref{ch4}), and follows from the conclusion of two other lemmas we will prove; Type Preservation (\ref{pres}) and Type Progress (\ref{prog})

\section{Lemmas for Type Safety}
There are two simple lemmas we must prove which will aid us in proving the lemmas of Type Safety:

%Another assumption is that if $x:A$ is in $\Gamma$ and we add $x:C$ to $\Gamma$, then the type of $x$ is overwritten?

\subsection{Weakening}\label{weak} 
Weakening is the following theorem, which says that for an expression of type $A$ in a context $\Gamma$, adding another variable $x$ (of any type) to the context will not change the type of the expression:

\vspace{0.5cm}

\begin{thm}
If $\Gamma \vdash e:A$ then  $\Gamma,x:C \vdash e:A$ 
\end{thm}
 
\begin{proof}
We prove this theorem by induction on derivation trees, so if we have a derivation tree for our assumption then there exists a derivation tree for the conclusion.% We can use the inductive hypothesis

%\[ \Gamma \vdash e : A \Rightarrow \Gamma , x : C \vdash e : A \]


As there is only one derivation for a given judgement $\Gamma \vdash e : A$, we can use induction on the possible expressions:

\paragraph{Variables} We rename $x$ to $y$ using $\alpha$ equivalence. We assume $\Gamma \vdash y : A$, giving us the following derivation tree:

$$
\inferrule{\Gamma(y) = A}{\Gamma \vdash y : A}
$$ 

of which $\Gamma(y) = A$ is a subtree. $\Gamma$ is a function, so can also be represented by a set of (variable, type) pairs. Therefore $\Gamma, x: C$ is the set $\Gamma \ \cup \{(x,C)\}$. Therefore we define the function $(\Gamma,x:C)$, where $(\Gamma,x:C)(y) = A$ and for any other variable $z$, $(\Gamma, x:C)(z) = \Gamma(z)$. Then we just use the typing rule for variables to get the following derivation tree:

$$
\inferrule{(\Gamma, x : C) (y) = A}{\Gamma, x : C \vdash y : A}
$$ 

Now we have the required derivation tree, so weakening holds for variables.

\paragraph{Zero} We assume $\Gamma \vdash z : \nat$, giving us the following derivation tree:
$$
\inferrule{ \ }{\Gamma \vdash z : \nat}
$$.
The typing rule for zero says that no matter what $\Gamma$ is, we always have zero, because there are no assumptions. Therefore we can have $\Gamma, x: C$ as the context and get the following derivation tree:
$$
\inferrule{ \ }{\Gamma,x :C \vdash z : \nat}
$$

Now we have the required derivation tree, so weakening holds for zero.

\paragraph{Successor} We assume $\Gamma \vdash s(e) : \nat$, giving us the following derivation tree from the typing rule:
$$
\inferrule{\Gamma \vdash e : \nat}{\Gamma \vdash s(e) : \nat}
$$.

where $\Gamma \vdash e : \nat$ is a subtree. We can use the inductive hypothesis of weakening on this subtree to get $\Gamma , x : C \vdash e : \nat$. Then we use the typing rule for successor to get the following derivation tree:

$$
\inferrule{\Gamma, x : C \vdash e : \nat}{\Gamma, x : C \vdash s(e) : \nat}
$$.

Now we have the required , so weakening holds for the successor function.

\paragraph{Case} We assume $\Gamma \vdash \ \case \ (e, z \mapsto e_0 , s(y) \mapsto e_S) : A$, (renaming $x$ to $y$ using alpha equivalence) giving us the following derivation tree from the typing rule:

$$
\inferrule{\Gamma \vdash e : Nat \\  \Gamma \vdash e_0 : A \\  \Gamma , y:\nat \vdash e_S : A}
  {\Gamma \vdash \ \case \ (e, z \mapsto e_0 , s(y) \mapsto e_S) \  : A}  
$$

giving us the subtrees $\Gamma \vdash e : \nat$, $\Gamma \vdash e_0 : A$ and $\Gamma, y : \nat \vdash e_S : A$ from the assumption of the typing rule. Using the inductive hypothesis on each of these, we get $\Gamma, x : C \vdash e : \nat$, $\Gamma, x : C \vdash e_0 : A$ and $\Gamma, y : \nat , x : C \vdash e_S : A$, so we can use the typing rule again with these assumptions:

$$
\inferrule{\Gamma, x : C \vdash e : Nat \\  \Gamma, x : C \vdash e_0 : A \\  \Gamma, x : C , y:\nat\vdash e_S : A}
  {\Gamma, x : C \vdash \ \case \ (e, z \mapsto e_0 , s(y) \mapsto e_S) \  : A}  
$$

Now we have the required derivation tree, so weakening holds for the case expression.
 
\paragraph{Application} We assume $\Gamma \vdash e_0 \ e_1 : B$, giving us the following derivation tree:

$$
\inferrule{\Gamma \vdash e_0 : A \to B \\ \Gamma \vdash e_1 : A}{\Gamma \vdash e_0 \ e_1 : B}
$$

which gives us the subtrees $\Gamma \vdash e_0 : A \to B$ and $\Gamma \vdash e_1 : A$. Using the inductive hypothesis on these trees gives us $\Gamma, x : C \vdash e_0 : A \to B$ and $\Gamma, x : C \vdash e_1 : A$, so we can just use the typing rule for application again to get the following derivation tree:

$$
\inferrule{\Gamma, x :C \vdash e_0 : A \to B \\ \Gamma, x: C \vdash e_1 : A}{\Gamma, x : C \vdash e_0 \ e_1 : B}
$$

Therefore weakening holds for function application.


\paragraph{Abstraction} We rename $x$ to $y$ using $\alpha$ equivalence. We assume $\Gamma \vdash \lambda y : A. \ e : B$, giving us the following derivation tree:

$$
\inferrule{\Gamma, y : A \vdash e : B}{\Gamma \vdash \lambda y : A. \ e : A \to B}
$$

which gives us the subtree $\Gamma , y:A \vdash e : B$. Using the inductive hypothesis, we get $\Gamma , y:A , x : C \vdash e : B$. Then we use the typing rule for $\lambda$ abstraction to get the following tree:

$$
\inferrule{\Gamma, y : A, x : C \vdash e : B}{\Gamma, x : C \vdash \lambda y : A. \ e : A \to B}
$$

Now we have the required derivation tree, so weakening holds for $\lambda$ abstraction.
 

\paragraph{Fixpoint}
 
We assume $\Gamma \vdash \fix \ y :A. \ e: A$, renaming $x$ to $y$ using $\alpha$ equivalence. This gives us the following derivation tree:

$$
\inferrule{\Gamma, y:A \vdash e : A}{\Gamma, y : A \vdash \fix \ y : A. \ e : A}
$$

As we have the subtree $\Gamma, y:A \vdash e : A$, we use the inductive hypothesis on this to get $\Gamma, x :C, y:A. \vdash e : A$. Then we use the typing rule for fix to get the following tree:

$$
\inferrule{\Gamma, x : C, y:A \vdash e : A}{\Gamma, x : C, y : A \vdash \fix \ y : A. \ e : A}
$$

Therefore weakening holds for the fixpoint operator. Now we have proved weakening for derivation trees of any expression so weakening always holds.


\end{proof}


\subsection{Substitution Rules} 
Next we want to prove a lemma that shows that substitutions preserve the intended type of a given PCF expression.

But before we prove this, we must actually define rules for substitution on the level of each possible expression that can be formed in PCF, which are all instances of $[e/x]e'$. This notation says that an expression $e$ replaces a variable $x$ in another expression $e'$.

When defining the substitution rules, we must be careful  that we avoid \textbf{variable capture} by bound variables. For example, given the following substitution:

\[ [s(x)/y](\lambda x. x + y) \]

if we naively substitute $s(x)$ for $y$ in $\lambda x. x + y$, we get $\lambda x. \ x + s(x)$ and the value of $x$ is now the value assigned to the bound $x$. Therefore we can use \textbf{renaming} to avoid this. 

\paragraph {Variables} There are two cases for substitution in variables. The first is for when $e'$ is the same as the variable being replaced:
\[[e/x]x = e\]
The second one is when $e$ is a completely different variable, for which nothing happens:
\[ [e/x]y = y\]

\paragraph{Zero} For zero, any substitution will have no effect, as zero is a constant:
\[ [e/x]z = z\]

\paragraph{Successor} The successor function cannot be changed, so we substitute $e$ in its argument:
 \[[e/x]s(e') = s([e/x]e')\]
 
\paragraph{Case} As we cannot change the case statement, we could substitute $e$ in the expressions given as arguments to the case statement, in the following way: 

\[ [e/x] \ (\case \ (e', z \mapsto e_0, s(x) \mapsto e_S)) = \case \ ([e/x]e', z \to [e/x]e_0, s(x)  \to [e/x]e_S)\]

But we must be careful with variable capture, as the derivation of $e_S$ is $\Gamma, x:Nat \vdash e_S$. If we have $[s(x)/y] e_S$ and $e_S = x + y$, then we have $x + s(x)$ and the value of $s(x)$ is bound by $\Gamma, x : Nat$. Therefore we should rename $s(x)$ in the case statement to something that is not free in $e_S$.

Therefore our rule for case will be:

\begin{minipage}{4in}
\begin{align*}
\intertext{$(\case \ (e', z \to e_0, s(x) \to e_S))=$}
  \begin{cases}
            (\case \ ([e/x]e', z \mapsto [e/x]e_0, s(x) \mapsto [e/x]e_S)) & \text{if } x \notin FV(e')  \\
            (\case \ ([e/x]e', z \mapsto [e/x]e_0, s(y) \mapsto [e/x]e_S)) & \text{if } x \in FV(e')
  \end{cases}
\end{align*} 
\end{minipage}

where $y \notin FV(e')$. 

For some expression $e$, $FV(e)$ is the set of free variables it contains.

\paragraph{Application} We substitute $e$ in the function and its argument, then apply the new function to the new argument:

\[ [e/x] (e_0 \ e_1) = [e/x]e_0 \ ([e/x]e_1) \]

\paragraph{$\lambda$ Abstraction} There are two cases, the first when the bound variable is $x$. This does nothing, as we are just rewriting the function using alpha equivalence in this case:
\[ [e/x](\lambda x:A. \ e') = \lambda x:A. \ e' \]
The second case is when the bound variable is not equal to $x$, where we substitute $e$ in the expression. If $y$ is a free variable in $e'$ then we must rename the bound variable to something else:

\begin{minipage}{4in}
\begin{align*}
\intertext{$[e/x](\lambda y:A.e')=$}
  \begin{cases}
            \lambda y:A. [e/x]e' & \text{if } y \notin FV(e')  \\
           \lambda z:A. [e/x]([z/y]e') & \text{if } y \in FV(e')
  \end{cases}
\end{align*} 
\end{minipage}

where $z \notin FV(e')$.

\paragraph{Fixpoint} Fixpoint is similar to $\lambda$ abstraction, so we have two cases. The first case is when the bound variable is $x$, for which we just rewrite the function using $\alpha$ equivalence. Therefore this rule does nothing:
\[ [e/x] \fix \ x:A. e' = \fix \ e:A. e'\]
When the bound variable is not equal to $x$, we substitute $e$ in the expression $e'$. If $y$ is a free variable in $e'$ then we must rename the bound variable to something else:

\begin{minipage}{4in}
\begin{align*}
\intertext{$[e/x](\fix \ y:A.e')=$}
  \begin{cases}
            \fix \ y:A. [e/x]e' & \text{if } y \notin FV(e')  \\
           \fix \ z:A. [e/x]([z/y]e') & \text{if } y \in FV(e')
  \end{cases}
\end{align*} 
\end{minipage}

where $z \notin FV(e')$.

\subsection{Substitution}

Now we have all the rules, we can prove Substitution, which is the following theorem. It says that if we have an expression $e$ that is well typed in the context $\Gamma$ and an expression $e'$ that is well typed in the context $\Gamma,x:A$, then the expression obtained by substituting $e$ for $x$ in $e'$ will be derivable in the context $\Gamma$:

\vspace{0.5cm}

\begin{thm}If $\Gamma \vdash e:A$ and $\Gamma, x:A \vdash e' : C$ then $\Gamma \vdash [e/x] e' : C$ \end{thm}

\begin{proof}
We can slso prove this by induction on derivation trees. %We can rewrite the theorem as "If $D :: \Gamma \vdash e:A$ and $E :: \Gamma, x:A \vdash e' : C$ then $F ::\Gamma \vdash [e/x] e' : C$, where $D$, $E$ and $F$ are derivation trees for each of the well typed terms. We use induction on the tree $E$, as we are interested in the possible expressions $e'$ could be. We can use the inductive hypothesis:

%\[(\Gamma \vdash e:A \ \wedge \Gamma, x:A \vdash e' : C) \Rightarrow \ \Gamma \vdash [e/x] e' : C\]

As there is only one derivation for a given judgement $\Gamma \vdash e : A$, again we can use induction on the possible values of $e'$:

\paragraph{Variables} We assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x : A \vdash y : C$. As $y$ has a different type to $x$, it cannot be equal to it, so there is only one case, as we can only use one of the substitution rules. The tree for $y$ that is given is:

$$\inferrule{(\Gamma,x:A)(y) = C}{\Gamma, x:A \vdash y : C}$$

The function $\Gamma$ is the set of pairs $(\Gamma,x:A)\backslash \{(x,A)\}$. As $x:A$ does not affect the value of $y$, we will still have $\Gamma(y) = C$. Using the typing rule for variables, we get the tree:

$$\inferrule{\Gamma(y) = C}{\Gamma \vdash y : C}$$

$\Gamma \vdash y : C$ will be the same as $\Gamma \vdash [e/x]y : C$ using the substitution rule for variables, so we have the derivation tree needed. Therefore variables satisfy substitution.  

\paragraph{Zero} We assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x : A \vdash z : \nat$. As $z$ is a constant, it exists in any context $\Gamma$, so we have a tree for $\Gamma \vdash z : \nat$. This is equal to $\Gamma \vdash [e/x]z : \nat$, as this is always zero no matter what $e$ and $x$ are. Therefore as we already have the tree for $\Gamma \vdash z : \nat$, we use it as the derivation tree for $\Gamma \vdash [e/x]z : \nat$.

\paragraph{Successor} We assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x:A \vdash s(e') : \nat$. The second tree is the following:

$$\inferrule{\Gamma, x:A \vdash e' : \nat}{\Gamma, x:A \vdash s(e') : \nat}$$

Therefore we have a subtree $\Gamma, x:A \vdash e' : \nat$. Using the induction hypothesis on this and $\Gamma \vdash e : A$, we have a derivation tree for $\Gamma \vdash [e/x]e' : \nat$. Using the typing rule for successor on this gives us the following tree:

$$\inferrule{\Gamma \vdash [e/x]e' : \nat}{\Gamma \vdash s([e/x]e') : \nat}$$

Using the substitution rule for successor, we know the bottom half is equal to $[e/x]s(e')$, so we get the following derivation tree:

 $$\inferrule{\Gamma \vdash [e/x]e' : \nat}{\Gamma \vdash [e/x]s(e') : \nat}$$
 
which is a derivation tree for $\Gamma \vdash [e/x]s(e') : \nat$. Therefore substitution holds for successor function.

\paragraph{Case} We rename $x$ to $y$ using alpha equivalence, then assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x: A \vdash \case \ (e', z \mapsto e_0 , s(y) \mapsto e_S) \  : C$. The second derivation tree gives us the subtrees $\Gamma, x:A \vdash e' : \nat$, $\Gamma, x : A \vdash e_0 : C$ and $\Gamma, y:Nat, x : A \vdash e_S : C$. Using the induction hypothesis and the tree for $\Gamma \vdash e : A$, we get  $\Gamma \vdash [e/x]e' : \nat$ and $\Gamma \vdash [e/x]e_0 : C$.

For $\Gamma, y:\nat, x : A \vdash e_S : C$, we need  to change the context of $e$ before we can apply the inductive hypothesis. We do this using our  Weakening Lemmma we just proved (in Section \ref{weak}), which gives us $\Gamma, y:\nat \vdash e : A$. Now we apply the inductive hypothesis with this to get $\Gamma, y:\nat \vdash [e/x]e_S : C$.
 
 
Now we can apply the typing rule to these trees to get the following derivation tree:

$$\inferrule{\Gamma \vdash [e/x]e' : \nat \\  \Gamma \vdash [e/x]e_0 : C \\  \Gamma , y:\nat \vdash [e/x]e_S : C}  {\Gamma \vdash \ \case \ ([e/x]e', z \mapsto [e/x]e_0 , s(y) \mapsto [e/x]e_S) \  : C}  
$$

By the substitution rule for case, we can replace the bottom half of the tree with $\Gamma \vdash [e/x] \ \case \ (e', z \mapsto e_0 , s(y) \mapsto e_S) \  : C$. Therefore substitution holds for the case statement. 

\paragraph{Application} We assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x : A \vdash e_0 \ e_1 : C$. The second tree is the following:

$$
\inferrule{\Gamma , x:A \vdash e_0 : B \to C \\  \Gamma ,x:A \vdash e_1 : B}
  {\Gamma, x : A \vdash e_0 \ e_1 : C}$$

which contains the subtrees $\Gamma, x:A \vdash e_0 : B \to C$ and $\Gamma, x:A \vdash e_1 : B$. Combining each of these trees with $\Gamma \vdash e : A$ and the inductive hypothesis gives us $\Gamma \vdash [e/x]e_0 : B \to C$ and $\Gamma \vdash [e/x]e_1 : B$. Using the typing rule for function application with these trees gives us a derivation tree for $\Gamma \vdash [e/x]e_0 ([e/x]e_1) : C$. This is equal to $\Gamma \vdash [e/x](e_0 \ e_1) : C$, so we have the derivation tree for this judgement.

Therefore substitution holds for function application.

\paragraph{Abstraction} We rename $x$ to $y$ using $\alpha$ equivalence. Then derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x : A \vdash \lambda y : B. \ e' : B \to C$. For the second tree we have the following:

$$\inferrule{\Gamma, x : A, y : B \vdash e' : C}{\Gamma, x:A \vdash \lambda y:B. \ e' : B \to C}$$

which gives us the subtree $\Gamma, x : A, y : B \vdash e' : C$. Then we use weakening on $\Gamma \vdash e : A$ to get $\Gamma, y : B \vdash e : A$
, which when used with the inductive hypothesis gives us $\Gamma, y : B \vdash [e/x]e' : C$. 


Applying the typing rule for $\lambda$ abstraction to this gives us the following tree:

$$\inferrule{\Gamma, y : B \vdash [e/x]e' : C}{\Gamma \vdash \lambda y:B. \ [e/x]e' : B \to C}$$.

Now there are two cases:

\begin{enumerate}
\item{When $y \notin FV(e')$, the substitution rule gives us $\lambda y:B. \ [e/x]e' = [e/x]\lambda y:B. \ e'$, so we have a derivation tree for $\Gamma \vdash [e/x]\lambda y:B. \ e' : B \to C$}
\item{When $y \in FV(e')$, rewrite $\lambda y:B. \ [e/x]e' : B \to C$ as $\lambda z:B. [e/x]([z/y]e')$. Then this is the same as $[e/x]\lambda y:B. \ e'$ , so we have a derivation tree for $\Gamma \vdash [e/x]\lambda y:B. \ e' : B \to C$} 
\end{enumerate} 


\paragraph{Fixpoint} We rename $x$ to $y$ using alpha equivalence, then assume derivation trees exist for $\Gamma \vdash e : A$ and $\Gamma, x : A \vdash \fix \ y:C. \ e' : C$. The second tree is the following:


$$\inferrule{\Gamma, y:C, x:A \vdash e' : C}{\Gamma,x:A \vdash \fix \ y:C. e' : C}$$

giving us the subtree $\Gamma, y:C, x:A \vdash e' : C$. Then we use weakening on $\Gamma \vdash e : A$ to get $\Gamma, y : C \vdash e : A$, which when used with the inductive hypothesis gives us $\Gamma, y:C \vdash [e/x]e' : C$. 

Applying the typing rule for fixpoint to this gives us the following derivation tree:

$$\inferrule{\Gamma, y:C \vdash [e/x]e' : C}{\Gamma\vdash \fix \ y:C. [e/x]e' : C}$$

Now there are two cases:

\begin{enumerate}
\item{When $y \notin FV(e')$, the substitution rule for fixpoint gives us $\Gamma\vdash \fix \ y:C. [e/x]e' : C = \Gamma \vdash [e/x](\fix \ y:C. e') : C$, so we have the required derivation tree and substitution holds for fixpoint.}
\item{When $y \in FV(e')$, rewrite $\fix \  y:C. \ [e/x]e' : C$ as $\fix \ z:C. [e/x]([z/y]e')$. Then this is the same as $[e/x]\fix \  y:C. \ e'$ , so we have a derivation tree for $\Gamma \vdash [e/x]\fix \  y:C. \ e' : C$}
\end{enumerate}


Now we have proved substitution holds for derivation trees of any expression $e'$.
\end{proof}

\section{Type Safety}
Now we can prove the two lemmas that form the property of Type Safety.

\subsection{Type Preservation} \label{pres}
Type preservation says that if an expression $e$ of type $A$ is well typed in a context $\Gamma$, and it evaluates in one step to $e'$, then $e'$ will also have type $A$ in $\Gamma$ (i.e.\ we get the same type at the end of the evaluation as we had at the start):
\vspace{0.5cm}

\begin{thm}
 If $\Gamma \vdash e:A$ and $e \mapsto e'$, then $\Gamma \vdash e' : A$
\end{thm}

\begin{proof}
We can prove this by induction on derivation trees.%, so we rewrite the theorem as "If $D :: \Gamma \vdash e:A$ and $E ::e \mapsto e'$ (in one step) then $\exists. F :: \Gamma \vdash e' : A$:

There will be a derivation tree  for each rule in the operational semantics, so we can check this statement for every evaluation rule on every possible expression:

\paragraph{Variables} There are no rules in the operational semantics for when $e$ is just a variable so we do nothing here.

\paragraph{Zero} Same as for variables.

\paragraph{Successor} We  assume $\Gamma \vdash s(e) : \nat$, so we have the following tree (by the typing rule of successor):

$$
\inferrule { \Gamma \vdash e : \nat }
 {\Gamma \vdash s(e) : \nat}
$$

Then we assume $s(e) \mapsto s(e')$, so we have the following tree, using the congruence rule for successor:
$$
\inferrule { e \mapsto e'} {s(e) \mapsto s(e')}
$$

From these two trees, we get the subtrees $\Gamma \vdash e : \nat$ and $e \mapsto e'$. Using the inductive  hypothesis of type preservation we get a tree for $\Gamma \vdash e' : \nat$. Then using the typing rule for successor with this we get a tree for $\Gamma \vdash s(e') : \nat$. 

There are no other rules when the expression is $s(e)$, so type preservation holds for successor expressions.  

\paragraph{Case} There are three evaluation rules, which depend on the expression $e$ being checked:

\begin{enumerate}
\item{If $e$ can be reduced, then we have the following tree from the typing rule for case:

$$
\inferrule{\Gamma \vdash e : \nat \\  \Gamma \vdash e_0 : A \\  \Gamma , x:\nat\vdash e_S : A}
  {\Gamma \vdash \ \case \ (e, z \mapsto e_0 , s(x) \mapsto e_S) \  : A}  
$$


and our second assumption uses the congruence evaluation rule for case as:

$$
\inferrule { e \mapsto e'} {\case \ (e, z \mapsto e_0 , s(x) \mapsto e_S) \mapsto \case \ (e', z \mapsto e_0 , s(x) \mapsto e_S)}
$$

Then we have subtrees for $\Gamma \vdash e : \nat$, $\Gamma \vdash e_0 : A$, $\Gamma , x : \nat \vdash e_S : A$ and $e \mapsto e'$.

Using the inductive hypothesis of type preservation, with the trees for $\Gamma \vdash e : \nat$ and $e \mapsto e'$ we get a tree for $\Gamma \vdash e' : \nat$. Then we apply the typing rule for case with this, $\Gamma \vdash e_0 : A$ and $\Gamma , x : \nat \vdash e_S : A$ to get a tree for $\Gamma \vdash case \ (e', z \to e_0 , s(x) \to e_S):A$}
\item{If $e = \case \ (z, z \mapsto e_0 , s(x) \mapsto e_S)$, then we get the following tree from the typing rule:

$$
\inferrule{\Gamma \vdash z : \nat \\  \Gamma \vdash e_0 : A \\  \Gamma , x:\nat\vdash e_S : A}
  {\Gamma \vdash \ \case \ (z, z \mapsto e_0 , s(x) \mapsto e_S) \  : A}  
$$
and we also have  the tree for the evaluation rule $\case \ (z, z \mapsto e_0 , s(x) \to e_S) \mapsto e_0$. Therefore we  need a tree for $\Gamma \vdash e_0 : A$, which we already have, as a subtree of the first assumption.}
\item{If $e = \case \ (s(v), z \mapsto e_0 , s(x) \mapsto e_S)$, then the tree formed from its typing rule is:

$$
\inferrule{\inferrule{\Gamma \vdash v : \nat}{\Gamma \vdash s(v) : \nat} \\  \Gamma \vdash e_0 : A \\  \Gamma , x:\nat\vdash e_S : A}
  {\Gamma \vdash \ \case \ (s(v), z \mapsto e_0 , s(x) \mapsto e_S) \  : A}  
$$
and we also have is the tree for the evaluation rule: $\case \ ( s(v)
, z \mapsto e_0 , s(x) \mapsto e_S) \mapsto [v/x]e_S$.

%We have the subtrees for $\Gamma \vdash v : \nat$, $\Gamma \vdash s(v) : \nat$, $\Gamma \vdash e_0 : A$, $\Gamma, x : \nat \vdash e_S : \nat$ from our first assumption.

We get the tree for $\Gamma \vdash [v/x]e_S :  A$ by using the substitution lemma, with the subtrees for $\Gamma \vdash v :\nat$ and $\Gamma , x : \nat \vdash e_S : A$ as parameters.}
\end{enumerate}
\paragraph{Application} There are two evaluation rules for function application:
\begin{enumerate}
\item{When $e$ is a function that can be reduced further, we have the following tree from its typing rule: 

$$
\inferrule{\Gamma \vdash e_0 : A \to B \\  \Gamma \vdash e_1 : A}
  {\Gamma \vdash e_0 \ e_1 : B}
$$  

and the following tree obtained from its evaluation rule:

$$
\inferrule {e_0 \mapsto e_0'} {e_0 \ e_1 \mapsto e_0' \ e_1}
$$

We use the induction hypothesis with the subtrees for $\Gamma \vdash e_0 : A \to B$ and $e_0 \mapsto e_0'$ to get a subtree for $\Gamma \vdash e_0' : A \to B$. Then using this and the subtree for $\Gamma \vdash e_1 : B$ , in the typing rule for function application, we get a subtree for $\Gamma \vdash e_0' \ e_1 : B$. }
\item{When $e = (\lambda x: A .\ e) \ e'$, we have the following tree from its typing rule:

$$
\inferrule{\inferrule{\Gamma, x : A \vdash e : B}{\Gamma \vdash (\lambda x :A).e : A \to B} \\  \Gamma \vdash e' : A}
  {\Gamma \vdash (\lambda x :A).e \ e' : B}
$$  

And the tree for $(\lambda x :A).e \ e' \mapsto [e'/x]e$ from its evaluation rule. We have subtrees $\Gamma \ \vdash e' : A$ and $\Gamma, x : A \vdash e : B$, so we use these as parameters to the Substitution Lemma to get the tree for $\Gamma \vdash [e'/x]e : B$.}
\end{enumerate}

\paragraph{$\lambda$-abstraction} has no evaluation rules when taken as a single expression (because it is a value).

\paragraph{Fixpoint}
When $e = \fix \ x:A. e$, we have the following tree from its typing rule:
$$
\inferrule{\Gamma, x : A \vdash e : A }
  {\Gamma \vdash \  \fix \ x:A . \ e : A}
$$

and the tree for $\fix \ x:A . \ e \mapsto [\fix \ x:A. e/x]e$ from its evaluation rule. We already have the tree for $\Gamma \vdash \  \fix \ x:A . \ e : A$ as an assumption and $ \Gamma, x : A \vdash e : A$ is a subtree of it, so we can use the substitution lemma with these parameters to get a tree for $\Gamma \vdash [\fix \ x:A . e/x]e :  A$

\vspace{1cm}

Now we have proved type preservation for all the rules in the operational semantics on all possible expressions.
\end{proof}

\subsection{Type Progress}\label{prog}
Type progress says that if an expression $e$ of type $A$ is well typed in a context $\Gamma$, then it must evaluate to another expression $e'$ in one step, or be a value (so $e$ cannot be evaluated further), where possible values are 
\[v :: z \ | \ s(v) \ | \ \lambda x : A. \ e\]
which are numbers or non-recursive functions (but note this is not saying the values terminate, or that they have normal form):

\vspace{0.5cm}

\begin{thm}
If $\vdash e : A$ then $e \mapsto e'$ or $e$ is a value.
\end{thm}

\begin{proof}
We can prove this by induction on derivation trees of $e$. When we have a derivation tree for a closed term $e$, we either get a derivation tree $E$, for evaluating it in one step to another expression, or $e$ is a value.  

\paragraph{Zero} $z$ is a value

\paragraph{Variables} There are no closed terms that are variables, so this is vacuously true. This is because the context of a term is a set of $(variable, type)$ pairs, so when it is empty, there are no variables. Therefore we have no derivation tree for $\vdash x : A$, where $x$ is a variable, so there is no case for variables.

\paragraph{Successor} When we have an expression $s(e)$, we assume $\vdash s(e) : \nat$, giving us the following tree:

$$
\inferrule {\vdash e : \nat }
 {\vdash s(e) : \nat}
$$

so we have a subtree for $\vdash e : \nat$. We can use induction on this subtree to get $e \mapsto e'$ or $e$ is a value. We then assume either side of this:

\begin{enumerate}
\item{When $e \mapsto e'$ we use the congruence rule for successor to get a tree for $s(e) \mapsto s(e')$. Therefore $s(e) \mapsto s(e')$ or $s(e)$ is a value}
\item{When $e$ is a value, $v$, we rewrite $s(e)$ to $s(v)$ This is a value, so $s(e) \mapsto s(e')$ or $s(e)$ is a value is true}
\end{enumerate}


\paragraph{Case} When we have an expression $\case  \ (e,z \mapsto e_0, s(x) \mapsto e_S)$, we assume $\vdash \case  \ (e,z \mapsto e_0, s(x) \mapsto e_S) :A$, giving us the following tree:

$$
\inferrule {\vdash e : \nat \\  \vdash e_0 : A \\  x: \nat\vdash e_S : A}
  {\vdash \ \case \ (e, z \mapsto e_0 , s(x) \mapsto e_S) \  : A}  
$$

so we have subtrees for $\vdash e : \nat$, $ \vdash e_0 : A$ and $ x:\nat \vdash e_S : A$.

By induction on $\vdash e : \nat$, we know that $e \mapsto e'$ or $e$ is a value. We can assume either side of this:

\begin{enumerate}
\item{When $e \mapsto e'$, we use the congruence rule for case to get $\case \ (e', z \mapsto e_0 , s(x) \mapsto e_S) \  : A$. Therefore we know our original expression maps to some other expression.}%, so we have $\case \ (e,z \mapsto e_0, s(x) \mapsto e_S) \mapsto e'$ for some $e'$}
\item{When $e$ is a value there are two cases.:
\begin{enumerate}
\item{$e = z$. The evaluation rule for this has no assumption, so we already have a tree that maps $\case \ (z, z \mapsto e_0 , s(x) \mapsto e_S)$ to another expression, which is $e_0$.}
\item{$e = s(v)$. The evaluation rule for this also has no assumption, so we already have a tree that maps $\case \ (s(v), z \mapsto e_0 , s(x) \mapsto e_S)$ to another expression, which is $[v/x]e_S$ }
\end{enumerate}
}
\end{enumerate}

Therefore, no matter what $e$ is in the case expression, it always maps to another expression, $e'$, so $\case \ (e, z \mapsto e_0 , s(x) \to e_S) \mapsto e'$ or $\case \ (e, z \to e_0 , s(x) \to e_S)$ is a value is true.

\paragraph{Application} When we have an expression $e_0 \ e_1$, we assume $\vdash e_0 \ e_1 : B$ giving us the following tree:

$$
\inferrule {\vdash e_0 : A \to B \\  \vdash e_1 : A}
  {\vdash e_0 \ e_1 : B}
$$

so we have a subtree for $\vdash e_0 : A \to B$. We can use the inductive hypothesis on this to get $e_0 \mapsto e'_0$ or $e_0$ is a value. We can assume either side of this:

\begin{enumerate}
\item{When $e_0 \mapsto e_0'$, we use the congruence rule for application to get a tree for $e_0 \ e_1 \mapsto e_0' \ e_1$}
\item{When $e_0$ is a value it must be $\lambda x:A. \  e_0$, as the other values are not function types. The evaluation rule for $(\lambda x:A. \ e_0 ) \ e_1$ has no assumption, so we already have a tree that maps $(\lambda x:A. \ e_0 ) \ e_1$ to another expression, which is $[e_1/x]e_0$}
\end{enumerate}

Therefore, for every possible value of $e_0 \ e_1$, we can evaluate it to another expression in one step, so $e_0 \ e_1 \mapsto e_0' \  e_1$ or $e_0 \ e_1$ is a value is true. 

\paragraph{$\lambda$-abstraction} $\lambda x:A. \ e$ is always a value, for any $x:A$ and $e : A$.

\paragraph{Fixpoint} When we have an expression $\fix \ x:A. \ e$, we assume $\vdash \ \fix \ x:A. \ e : A$, giving us the following tree:

$$
\inferrule {x : A \vdash e : A }
  { \vdash \  \fix \ x:A . \ e : A}
$$

There are no assumptions in the evaluation rule for fixpoint, so we already have the tree that maps $\fix \ x:A. \ e$ to another expression, which is  $[\fix \ x:A. e/x]e$. Therefore we know that $\fix \ x:A. \ e$ always maps to another expression. % so $\fix \ x:A. \ e$ maps to another expression $e'$ in one step, or $\fix \ x:A. \ e$ is a value is true.

Now we have proved type progress for all possible expressions.
\end{proof}

Now Type Safety can be  assumed from the the two lemmas we have just proved. This approach was first used in \citep{Wright94}. 


The theorem for type safety says that an closed term either evaluates to a value in a finite number of steps or loops forever:

\vspace{0.5cm}

\begin{thm}
If $\vdash e : A$ then $e \mapsto^* v$ (where $\vdash v : A$) or $e \mapsto^{\infty}$
\end{thm}

%\begin{proof} 
%We can prove this by coinduction, because the evaluation is infinite. 

%NEELS PROOF
%$$
%\inferrule{ \ }{v \ safe}
%$$

%$$
%\inferrule{e \mapsto e' \\ e' \ safe}{e \ safe}
%$$

%If $e$ is a value, e is safe

%If $e$ is not a value, by Type Progress $e \mapsto e'$ and by Type Preservation $\vdash e' : A$, so by coinduction we know e' is safe. Then we use the rule above to get that e is safe.

%MY PROOF
%By Type Progress we know that any closed term $e$ must evaluate to another expression in one step or be a value, so there are two cases:

%\begin{enumerate}
%\item{When $e$ is a value, then it is already safe}
%\item{When $e$ is an expression, by type progress 
%\item{When $e$ is a value, we have $v \mapsto^* v$ by reflexivity.}
%\item{When $e \mapsto e'$, we can use induction on the expression $e'$.
 %       \begin{itemize}
	%			\item{If $e'$ is a value, then $e \mapsto v$, so we have $e \mapsto^* v$}
	%			\item {If $e'$ is an expression then we know it evaluates to another expression $e''$, or a value, in one step. If we have the expression $e''$, then this will evaluate to another expression or value in one step. Therefore we can repeat this process forever, or until we get a value, so either we have a finite number of evaluations
 %and for some $v$, $e \mapsto^* v$, or we always get more expressions and $e \mapsto^{\infty}$. By Type Preservation and transitivity of $\mapsto^*$, we know that if we eventually get a value, it will have the same type as $e$, so we have $\vdash v : A$}
%\end{itemize}}
%\end{enumerate}

%\end{proof}
%\section{Problem Statement and why worth it.}
Semantics is the study of the meaning of computer programs. We require semantics because we can easily compile syntactically correct programs in some  language into machine code, but this does not tell us how they actually behave. There are many different approaches to semantics, but the main three are Operational \citep{Plotkin81}, Denotational \citep{Scott93} and Axiomatic Semantics \citep{Hoare69}.

In this report, we are interested in the first two approaches. Operational Semantics describes how a syntactic program is reduced to some other syntactic value either by using a transition relation, or "running" the program on an abstract machine. In Denotational Semantics, we construct a mathematical model of the language and analyse that instead of the syntax of the language.

In general, Denotational Semantics is considered to be more abstract, enabling us to remove detail that is unnecessary for analysing behaviour and just makes proofs less readable,  whereas Operational Semantics can be more easily linked to an implementation of a language. Also, the Operational Semantics of a language are usually proved to be sound with relation to the Denotational Semantics, in a theorem called Soundness (see Section \ref{sound}). In the other direction the theorem is usually referred to as Completeness. We will see that a result this strong cannot be proved for all languages, so instead we relate the denotational model of PCF to its Operational Semantics using a theorem called Adequacy (see Chapter \ref{Adequacy}). Therefore having both of these approaches to semantics is beneficial to analyse a the language in different ways. For example, later in the report we prove a property called Type Safety (see Chapter \ref{safe}), for which we use just the Operational Semantics of the language. In contrast, to prove that the Operational Semantics is sound we require both approaches.

\section{History}
Early examples of creating a mathematical model for a programming language include Landin's model for ALGOL 60 using the $\lambda$ calculus \citep{Landin64,Landin65}
and Gordon's denotational model for LISP \citep{Gordon73}.


The language we model is PCF (Programming Computable Functions). It is a programming language that is analysed by the research community more often than it is actually compiled and used to write programs. However, it forms a subset of popular functional languages like ML \citep{Milner97} and Haskell \citep{Marlow10}.

It was first discussed as a programming language and given semantics by Plotkin, \citep{Plotkin77}, but is inspired by a "Logic of Computable Functions" defined in \citep{Scott93} (a very famous article that was widely known and written in 1969, but not published until 1993 at Scott's request) and described by \citep{Milner73}. In \citep{Scott93}, a logical system is defined and an explanation of how it can modelled by specific mathematical structures is given. The structures used are partially ordered domains of continuous functions (which we define in section \ref{dom}).

A theorem prover was created for LCF in the work of \citep{Milner72a}, with an explanation of its working given by \citep{Milner72b}, in which the syntax and semantics of a simple language are described in the logic. It was applied to  describe and prove the correctness of a compiler in \citep{Milner72c}.

LCF was developed into the modern proof assistants HOL and Isabelle \citep{Nipkow02} and influenced many other systems. Also, it resulted in the creation of ML, which started as an aid for LCF, as discussed in \citep{Gordon00}.

Therefore although PCF is a research language, it has many applications, so studying it is worthwhile. \citep{Plotkin77} defines the theorem of Adequacy, which is what we ultimately prove, by using a technique called logical relations, which is a different approach to Plotkin's proof, but also documented in modern textbooks such as \citep{Streicher06}. 

%\section{Aims}
%In the project overall we aim to:
%
%\begin{itemize}
%\item{Study the operational and denotational semantics of the programming language PCF}
%\item{Prove that these semantics are equivalent at base type, by proving a theorem called Adequacy}
%\end{itemize}

\section{Structure}
In Chapter \ref{ch2}, we explain Domain Theory, a area of mathematics studying the structures that we use to specify our Denotational Semantics and logical relations, a proof technique required for proving Adequacy.

In chapter \ref{ch3}, we define the syntax of PCF and give the typing rules, which all syntactically correct PCF programs must satisfy. In Chapter \ref{ch4}, we specify the Operational  Semantics of PCF and in Chapter \ref{safe}, we prove Type Safety, which states that all correctly typed PCF programs must have a valid evaluation in the Operational Semantics if they are expected to.

In Chapter \ref{ch6}, we define our Denotational Semantics of PCF and prove that the Operational Semantics are sound with respect to this. In Chapter \ref{Adequacy}, we prove the Adequacy theorem and in Chapter \ref{ch8} we discuss other approaches to the proof of Adequacy. In Chapter \ref{por}, we discuss how there are functions in the denotational model that cannot be defined in PCF.

Finally our work is evaluated (in Chapter \ref{ch9}) and concluded (in Chapter \ref{ch10}).
%Finally in Chapter \ref{ch9} we consider the 
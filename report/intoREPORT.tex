%\section{Problem Statement and why worth it.}
Semantics is the study of the meaning of computer programs. We require this study because we can easily compile syntactically correct programs  of a language into machine code, but this does not tell us how the programs actually behave. There are many different approaches to semantics, but the main three are operational \citep{Plotkin81}, denotational \citep{Scott93} and axiomatic semantics \citep{Hoare69}.

In this report, we are interested in the first two approaches. Operational semantics describes how a syntactic program is reduced to some other syntactic value either by using a transition relation, or "running" the program on an abstract machine. In denotational semantics, we construct a mathematical model of the language and analyse that instead of the syntax of the language.

In general, denotational semantics is considered to be more abstract, enabling us to remove detail that is unnecessary for analysing behaviour and just makes proofs less readable,  whereas operational semantics can be more easily linked to an implementation of a language. Also, the operational semantics of a language are usually proved to be sound with relation to the Denotational Semantics, in a theorem called Correctness/Soundness (see Section \ref{sound}). In the other direction the theorem is usually referred to as Completeness. We will see that a result this strong cannot be proved for all languages and instead we relate the denotational model of PCF to its operational semantics using a theorem called Adequacy (see Chapter \ref{Adequacy}). Therefore having both of these approaches to semantics is beneficial to analyse a the language in different ways. For example, later in the report we prove a property called Type Safety (see Chapter \ref{safe}), for which we use just the operational semantics of the language, but to prove the operational semantics is sound we require both approaches.

\section{History}
Early examples of creating a mathematical model for a programming language include Landin's model for Algol 60 using the $\lambda$ calculus \citep{Landin64,Landin65}.
and Gordon's denotational model for LISP \citep{Gordon73}.


The language we model is PCF (Programming Computable Functions). It is a programming language that is analysed by the research community more often than it is actually compiled and used to write programs. However, it forms a subset of popular functional languages like ML \citep{Milner97} and Haskell \citep{Marlow10}.

It was first discussed as a programming language and given semantics by Plotkin, \citep{Plotkin77}, but is inspired by a "logic of computable functions" defined in \citep{Scott93}, (and described by \citep{Milner73}), a very famous article that was widely known and written in 1969 (but not published until 1993 at Scott's request). In this paper, Scott defines a logical system and explains how it can modelled by a specific mathematical structure, partially ordered domains of continuous functions (which we define in section \ref{dom}).

A theorem prover was created for LCF in the work of \citep{Milner72a}, with an explanation of its working given by \citep{Milner72b}, in which the syntax and semantics of a simple language are described in the logic. It was applied to  describe and prove the correctness of a compiler in \citep{Milner72c}.

LCF was developed into the modern proof assistants HOL and Isabelle \citep{Nipkow02} and influenced many other systems. Also, it resulted in the creation of ML, which started as an aid for LCF, as discussed in \citep{Gordon00}.

Therefore although PCF is a research language, it has many applications, so studying it is worthwhile. \citep{Plotkin77} defines the theorem of Adequacy, which is what we ultimately prove, by using a technique called Logical Relations, which is a different approach to Plotkin's proof, but also documented in modern textbooks such as \citep{Streicher06}. 

%\section{Aims}
%In the project overall we aim to:
%
%\begin{itemize}
%\item{Study the operational and denotational semantics of the programming language PCF}
%\item{Prove that these semantics are equivalent at base type, by proving a theorem called Adequacy}
%\end{itemize}

\section{Structure}
In Chapter \ref{ch2}, we explain \emph{Domain Theory}, a area of mathematics studying the structures that we use to specify our denotational semantics and \emph{Logical Relations}, a proof technique required for proving Adequacy

In chapter \ref{ch3}, we define the syntax of PCF and give the typing rules, which all syntactically correct PCF programs must satsify. In Chapter \ref{ch4}, we specify the operational semantics of PCF and in Chapter \ref{safe}, we prove Type Safety, which states that all correctly typed PCF programs must have a valid evaluation in the operational semantics if they are expected to.

In Chapter \ref{ch6}, we define our denotational semantics of PCF and prove that the operational semantics are sound with respect to this. In Chapter \ref{Adequacy}, we prove the Adequacy theorem and in Chapter \ref{ch8} contrast our proof with other approaches to the proof of Adequacy.

Finally our work is evaluated (in Chapter \ref{ch9}) and concluded (in Chapter \ref{ch10}).
%Finally in Chapter \ref{ch9} we consider the 